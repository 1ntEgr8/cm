#!/usr/bin/env bash

set -e

rm_file() {
    filepath="$1"
    filename=$(basename "$filepath")
    
    # check if file exists
    if [[ ! -e $filepath ]]; then
        error "File $filepath does not exist"
    fi

    # check if it is a file (and not a dir)
    if [[ ! -f $filepath ]]; then
        error "$filepath is not a file"
    fi
    
    links_path=$(dirname "$filepath")/links
    if [[ ! -e $links_path ]]; then
        info "no 'links' file found"
        info "skipping symlink check"
    else
        if out=$(grep -F "$filename" "$links_path"); then
            # warn about link
            symlink=$(echo "$out" | awk '{print $1}')

            # replace ~ with $HOME
            symlink=${symlink/#\~/$HOME}
            
            if [[ -L "$symlink" ]]; then
                warn "$symlink is symlinked to $filepath"
                warn "Removing '$filepath' will result in a broken symlink '$symlink'"

                if yes_or_no "Do you want to keep a copy of '$filepath' at '$symlink'?"
                then
                    unlink "$symlink"
                    cp "$filepath" "$symlink"
                    info "created copy"
                else
                    unlink "$symlink"
                    rm "$filepath"
                    info "removed $filepath and $symlink"
                fi
            fi

            # remove line from $links_path
            sed -i '' "/$filename/d" "$links_path"
        fi
    fi

    rm "$filepath"
    info "removed $filepath"
}

rm_formula() {
    local formula="$1"
    
    if ! is_formula "$formula"; then
        info "$formula is not a formula; skipping"

        # TODO insert a check to see if it is symlinked
    else
        items=$(ls -A "$formula")
        for item in $items; do
            dispatch "$formula/$item"
        done
        
        rm -d "$formula"
        info "removed $formula"
    fi
}

dispatch() {
    if [[ -d "$1" ]]; then
        rm_formula "$1"
    else
        rm_file "$1"
    fi
}

main() {
    for arg in "$@"; do
        dispatch "$arg"
    done
    success
}

"$@"
